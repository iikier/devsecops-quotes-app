# ========================================
# PIPELINE DEVSECOPS - GITHUB ACTIONS
# ========================================
# Pipeline completo com segurança integrada: SAST, Container Security, Dependency Scanning

name: 🛡️ DevSecOps Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  NODE_VERSION: '18'
  AWS_REGION: 'us-east-1'
  ECR_REPOSITORY: 'devsecops-quotes-app'

jobs:
  # ========================================
  # STAGE 1: SETUP & LINT
  # ========================================
  setup-and-lint:
    name: 🔍 Setup & Code Quality
    runs-on: ubuntu-latest
    outputs:
      changed-files: ${{ steps.changes.outputs.any }}
    steps:
      - name: 📥 Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: 📦 Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: 📦 Install Dependencies
        run: npm ci

      - name: 🧹 ESLint Check
        run: |
          npm install eslint --save-dev
          npx eslint . --ext .js,.jsx,.ts,.tsx --max-warnings 0 || echo "ESLint warnings found"

      - name: 🔍 Detect Changes
        id: changes
        uses: dorny/paths-filter@v2
        with:
          filters: |
            any:
              - '**/*.js'
              - '**/*.json'
              - '**/Dockerfile'
              - '**/*.tf'

  # ========================================
  # STAGE 2: SECURITY SCANS
  # ========================================
  security-scanning:
    name: 🛡️ Security Scanning
    runs-on: ubuntu-latest
    needs: setup-and-lint
    permissions:
      security-events: write
      actions: read
      contents: read
    steps:
      - name: 📥 Checkout Code
        uses: actions/checkout@v4

      # SAST - Static Application Security Testing
      - name: 🔍 SAST - CodeQL Analysis
        uses: github/codeql-action/init@v3
        with:
          languages: javascript

      - name: 🔍 SAST - CodeQL Autobuild
        uses: github/codeql-action/autobuild@v3

      - name: 🔍 SAST - CodeQL Analysis Upload
        uses: github/codeql-action/analyze@v3

      # SAST - Semgrep (Open Source)
      - name: 🔍 SAST - Semgrep
        uses: semgrep/semgrep-action@v1
        with:
          config: >-
            p/security-audit
            p/secrets
            p/owasp-top-ten
            p/javascript
        env:
          SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}

      # Dependency Vulnerability Scanning
      - name: 🔍 Dependency Scan - npm audit
        run: |
          echo "📦 Running npm audit..."
          npm audit --audit-level=moderate --json > npm-audit.json || true
          
          # Se houver vulnerabilidades críticas, falhar o pipeline
          CRITICAL=$(cat npm-audit.json | jq '.metadata.vulnerabilities.critical // 0')
          HIGH=$(cat npm-audit.json | jq '.metadata.vulnerabilities.high // 0')
          
          echo "🚨 Critical vulnerabilities: $CRITICAL"
          echo "⚠️ High vulnerabilities: $HIGH"
          
          if [ "$CRITICAL" -gt 0 ]; then
            echo "❌ Critical vulnerabilities found! Pipeline failed."
            exit 1
          fi

      - name: 🔍 Dependency Scan - Snyk
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high --json-file-output=snyk.json
        continue-on-error: true

      # Secret Scanning
      - name: 🔍 Secret Scan - TruffleHog
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: main
          head: HEAD
          extra_args: --debug --only-verified

      # Infrastructure Scanning
      - name: 🔍 IaC Scan - Checkov
        uses: bridgecrewio/checkov-action@master
        with:
          directory: terraform/
          framework: terraform
          output_format: sarif
          output_file_path: checkov.sarif
        continue-on-error: true

      - name: 📤 Upload Scan Results
        uses: actions/upload-artifact@v4
        with:
          name: security-scan-results
          path: |
            npm-audit.json
            snyk.json
            checkov.sarif

  # ========================================
  # STAGE 3: BUILD & TEST
  # ========================================
  build-and-test:
    name: 🔨 Build & Test
    runs-on: ubuntu-latest
    needs: [setup-and-lint, security-scanning]
    steps:
      - name: 📥 Checkout Code
        uses: actions/checkout@v4

      - name: 📦 Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: 📦 Install Dependencies
        run: npm ci

      - name: 🧪 Run Tests
        run: |
          echo "Running tests..."
          # npm test
          echo "✅ Tests passed (placeholder)"

      - name: 🐳 Build Docker Image
        run: |
          docker build -t devsecops-quotes-app:${{ github.sha }} .
          docker tag devsecops-quotes-app:${{ github.sha }} devsecops-quotes-app:latest

      # Container Security Scanning
      - name: 🔍 Container Scan - Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'devsecops-quotes-app:latest'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: 🔍 Container Scan - Grype
        uses: anchore/scan-action@v3
        with:
          image: 'devsecops-quotes-app:latest'
          fail-build: false
          output-format: sarif
          output-file: grype-results.sarif

      - name: 📤 Upload Container Scan Results
        uses: actions/upload-artifact@v4
        with:
          name: container-scan-results
          path: |
            trivy-results.sarif
            grype-results.sarif

      - name: 💾 Save Docker Image
        run: |
          docker save devsecops-quotes-app:latest | gzip > docker-image.tar.gz

      - name: 📤 Upload Docker Image
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: docker-image.tar.gz
          retention-days: 1

  # ========================================
  # STAGE 4: DEPLOY TO DEV
  # ========================================
  deploy-dev:
    name: 🚀 Deploy to Development
    runs-on: ubuntu-latest
    needs: [build-and-test]
    if: github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main'
    environment: development
    steps:
      - name: 📥 Checkout Code
        uses: actions/checkout@v4

      - name: 📥 Download Docker Image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: .

      - name: 🐳 Load Docker Image
        run: |
          docker load < docker-image.tar.gz
          docker tag devsecops-quotes-app:latest devsecops-quotes-app:dev

      - name: ⚙️ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: 🔑 Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: 🏗️ Terraform Init
        run: |
          cd terraform
          terraform init

      - name: 🔍 Terraform Plan
        run: |
          cd terraform
          terraform plan -var-file="dev.tfvars" -out=tfplan

      - name: 🚀 Terraform Apply
        run: |
          cd terraform
          terraform apply -auto-approve tfplan

      - name: 📤 Get Infrastructure Outputs
        id: terraform-outputs
        run: |
          cd terraform
          echo "public_ip=$(terraform output -raw compute_info | jq -r '.public_ip')" >> $GITHUB_OUTPUT
          echo "instance_id=$(terraform output -raw compute_info | jq -r '.instance_id')" >> $GITHUB_OUTPUT

      - name: 🚀 Deploy Application
        env:
          PUBLIC_IP: ${{ steps.terraform-outputs.outputs.public_ip }}
          INSTANCE_ID: ${{ steps.terraform-outputs.outputs.instance_id }}
        run: |
          echo "🚀 Deploying to EC2 instance: $INSTANCE_ID"
          echo "🌐 Public IP: $PUBLIC_IP"
          
          # Aguardar instância ficar pronta
          aws ec2 wait instance-status-ok --instance-ids $INSTANCE_ID
          
          # Copiar código para a instância
          echo "📦 Copying application files..."
          
          # Usar AWS SSM para executar comandos na instância
          aws ssm send-command \
            --instance-ids $INSTANCE_ID \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "cd /opt/devsecops-quotes",
              "git pull origin main || git clone https://github.com/${{ github.repository }} .",
              "sudo ./deploy.sh"
            ]' \
            --query 'Command.CommandId' \
            --output text > command_id.txt
          
          COMMAND_ID=$(cat command_id.txt)
          echo "📋 Command ID: $COMMAND_ID"
          
          # Aguardar comando completar
          aws ssm wait command-executed \
            --command-id $COMMAND_ID \
            --instance-id $INSTANCE_ID

      - name: 🧪 DAST - Application Security Testing
        env:
          PUBLIC_IP: ${{ steps.terraform-outputs.outputs.public_ip }}
        run: |
          echo "🔍 Running DAST against http://$PUBLIC_IP:3000"
          
          # Aguardar aplicação ficar disponível
          for i in {1..30}; do
            if curl -s "http://$PUBLIC_IP:3000/api/quote" > /dev/null; then
              echo "✅ Application is responding"
              break
            fi
            echo "⏳ Waiting for application... ($i/30)"
            sleep 10
          done
          
          # DAST com ZAP
          docker run -t zaproxy/zap-stable zap-baseline.py \
            -t "http://$PUBLIC_IP:3000" \
            -J zap-report.json || true

      - name: 📤 Upload DAST Results
        uses: actions/upload-artifact@v4
        with:
          name: dast-results
          path: zap-report.json

  # ========================================
  # STAGE 5: MONITORING & NOTIFICATIONS
  # ========================================
  monitoring-setup:
    name: 📊 Setup Monitoring
    runs-on: ubuntu-latest
    needs: [deploy-dev]
    if: success()
    steps:
      - name: 📊 Configure CloudWatch Alarms
        run: |
          echo "📊 Setting up monitoring and alerts..."
          
          # Criar alarm para CPU alta
          aws cloudwatch put-metric-alarm \
            --alarm-name "devsecops-quotes-dev-high-cpu" \
            --alarm-description "High CPU utilization" \
            --metric-name CPUUtilization \
            --namespace AWS/EC2 \
            --statistic Average \
            --period 300 \
            --threshold 80 \
            --comparison-operator GreaterThanThreshold \
            --evaluation-periods 2 \
            --alarm-actions arn:aws:sns:${{ env.AWS_REGION }}:${{ secrets.AWS_ACCOUNT_ID }}:devsecops-alerts

      - name: 🔔 Notify Deployment Success
        uses: 8398a7/action-slack@v3
        with:
          status: success
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          text: '🚀 DevSecOps Pipeline completed successfully! Application deployed to development environment.'

  # ========================================
  # FAILURE NOTIFICATION
  # ========================================
  notify-failure:
    name: 🚨 Notify Failure
    runs-on: ubuntu-latest
    needs: [setup-and-lint, security-scanning, build-and-test, deploy-dev]
    if: failure()
    steps:
      - name: 🚨 Notify Pipeline Failure
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          text: '❌ DevSecOps Pipeline failed! Please check the logs and fix the issues.' 